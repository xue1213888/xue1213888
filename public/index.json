[{"categories":["go runtime"],"content":"对一次性事件进行睡眠和唤醒。在调用 notesleep 或者 notewakeup 之前，必须调用 noteclear 来初始化 note 。然后，一个线程可以调用 notesleep ，一个线程可以调用 notewakeup 一次，一点调用了 notewakeup ， notesleep 就会返回。后续调用 notesleep 将立即返回。之后的 noteclear 必须在之前的 notesleep 返回后调用。比如，不允许在 notewakeup 之后直接调用 noteclear。 notetsleep 和 notesleep 类似，但即使事件尚未发生，也会在给定的ns后唤醒。如果一个 goroutine 使用 notetsleep 提前唤醒，它必须等待调用 noteclear ，直到可以确定没有其他 goroutine 在调用 notewakeup。 notesleep 和 notetsleep 通常被 g0 调用。 notetsleepg 与 notetsleep 相似，但被用户 g 调用。 这是一家只能打包带走餐厅。 小明来买午饭，需要通过 noteclear 拿走一个叫号牌，通过 notesleep 告诉老板钱付过了，这个牌子的号码绑定的就是我的午餐。老板把饭做好了要叫号 notewakeup ，我们听到叫号，就去拿餐，阻塞就结束了。老板只会叫一次号，可能我们没听到叫号，但是我们过去柜台看的话，餐就在那里放着，上面也写着是多少号的餐。也就是 notewakeup 后，继续调用 notesleep 不会阻塞，立即返回。 今天比较着急，我只愿意等10分钟，超时小明上课就迟到了，奖学金就没有了，所以小明通过 notetsleep 告诉老板我很急，只能等10分钟，小明在10分钟拿到餐就是正常情况，但可能老板没做出来，小明就不等了，老板做出来之后，看了看号码牌，好像没人要这个餐了。小明课上完如果想起来自己还有个餐没拿，过来也是能直接拿到的。 ","date":"2022-09-07","objectID":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/:0:0","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/"},{"categories":["go runtime"],"content":"结构 基于futex实现，key是一个uint32的值 基于sema实现，key是一个waitm type note struct { key uintptr } ","date":"2022-09-07","objectID":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/:1:0","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/"},{"categories":["go runtime"],"content":"基于sema实现 ","date":"2022-09-07","objectID":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/:2:0","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/"},{"categories":["go runtime"],"content":"初始化一次性通知或者清零一次性通知 // 就是给key设置成了0 func noteclear(n *note) { if GOOS == \"aix\" { atomic.Storeuintptr(\u0026n.key, 0) } else { n.key = 0 } } ","date":"2022-09-07","objectID":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/:2:1","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/"},{"categories":["go runtime"],"content":"阻塞等待通知 func notesleep(n *note) { // 得到g gp := getg() // 如果 g 不是 g0，我们抛出错误 if gp != gp.m.g0 { throw(\"notesleep not on g0\") } // 初始化信号 semacreate(gp.m) // 如果 key 是 0 ，证明这是一个新初始化的 note // 我们让他存储当前 m 的地址 if !atomic.Casuintptr(\u0026n.key, 0, uintptr(unsafe.Pointer(gp.m))) { // 如果存储失败，证明 n.key 不是 0。 // 如果我们的已经调用了 notewakeup ， 导致 n.key 是 locked，那么我们就返回 // 如果 n.key 不是 locked 也不是锁定状态，我们这边还要阻塞的话，就报错。 if n.key != locked { throw(\"notesleep - waitm out of sync\") } return } // n.key 存储了 m 的地址，成功了，我们要让他等待 gp.m.blocked = true if *cgo_yield == nil { // 无限等待通知 semasleep(-1) } else { // 休眠一个任意但适中的间隔来轮询 libc 拦截器。 const ns = 10e6 // 如果这个时候 n.key 是 0 的话，证明被 wakeup 了 for atomic.Loaduintptr(\u0026n.key) == 0 { semasleep(ns) asmcgocall(*cgo_yield, nil) } } gp.m.blocked = false } 流程如下 现在 g0 要阻塞直到得到一个通知。 检查 note.key != 0 ，证明这个 note 已经被 wakeup(==locked) 或者 当前正在 sleep(==waitm) 中。 继续判断如果 note.key != locked ，也就是已经 sleep ，我们就报错，因为已经这个 note 上面正在睡眠等待，如果 note.key == locked 证明已经被唤醒，我们就直接返回，因为我们只会唤醒一次，后续调用 sleep 将不会进行阻塞 如果 note.key == 0 ，我们就将 m 的地址存入 note.key 中。开启信号量等待就好了 ","date":"2022-09-07","objectID":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/:2:2","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/"},{"categories":["go runtime"],"content":"唤醒通知 func notewakeup(n *note) { var v uintptr for { // v 是我们 n.key 的值 v = atomic.Loaduintptr(\u0026n.key) // 如果 v 没有被其他线程修改，我们就让它的状态为locked if atomic.Casuintptr(\u0026n.key, v, locked) { break } } // 这里的 v 还是之前 key 的值 switch { case v == 0: // 如果之前 v == 0 证明之前就是一个解锁的状态，并且没有存储waitm，我们直接结束就好了，加锁已经完成 case v == locked: // 如果之前就是锁定的，我们就报错 throw(\"notewakeup - double wakeup\") default: // v 里面存储的是一个 waitm semawakeup((*m)(unsafe.Pointer(v))) } } ","date":"2022-09-07","objectID":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/:2:3","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/"},{"categories":["go runtime"],"content":"带最大唤醒等待时间的等待 func notetsleep(n *note, ns int64) bool { gp := getg() if gp != gp.m.g0 { throw(\"notetsleep not on g0\") } semacreate(gp.m) return notetsleep_internal(n, ns, nil, 0) } func notetsleep_internal(n *note, ns int64, gp *g, deadline int64) bool { // gp 和 deadline 按逻辑来说是局部变量，但是为了存在调用者的栈中，我们写成了参数 // 这减少了 notetsleep_internal 的 nosplit 占用空间。 // 拿到 g ， 这个 g 是 g0 gp = getg() // 如果 n.key != 0 if !atomic.Casuintptr(\u0026n.key, 0, uintptr(unsafe.Pointer(gp.m))) { if n.key != locked { // 对已经阻塞的 note ，继续阻塞 throw(\"notetsleep - waitm out of sync\") } // 已经被唤醒的note return true } // 如果 n.key == 0，n.key = uintptr(unsafe.Pointer(gp.m)) // 当前 key 是要阻塞 m 的地址 if ns \u003c 0 { // 小于0，就是无限等待，跟上面逻辑一样 gp.m.blocked = true if *cgo_yield == nil { semasleep(-1) } else { // Sleep in arbitrary-but-moderate intervals to poll libc interceptors. const ns = 10e6 for semasleep(ns) \u003c 0 { asmcgocall(*cgo_yield, nil) } } gp.m.blocked = false return true } // 当 ns \u003e= 0，证明要有一个超时唤醒时间 deadline = nanotime() + ns for { gp.m.blocked = true if *cgo_yield != nil \u0026\u0026 ns \u003e 10e6 { ns = 10e6 } // semasleep(ns) \u003e= 0 代表着在规定时间内正常被唤醒，我们返回true if semasleep(ns) \u003e= 0 { gp.m.blocked = false // Acquired semaphore, semawakeup unregistered us. // Done. return true } // 小小休息一下，防止空耗cpu if *cgo_yield != nil { asmcgocall(*cgo_yield, nil) } gp.m.blocked = false // Interrupted or timed out. Still registered. Semaphore not acquired. ns = deadline - nanotime() // 等待超时了 if ns \u003c= 0 { break } // Deadline hasn't arrived. Keep sleeping. } // 我们超时拿不到信号量通知，要放弃了 for { // v 就是 waitm v := atomic.Loaduintptr(\u0026n.key) switch v { case uintptr(unsafe.Pointer(gp.m)): // 取消注册，返回，清空这个key，如果别人再来唤醒，也根本啥事不做了 if atomic.Casuintptr(\u0026n.key, v, 0) { return false } case locked: // 其他线程把note唤醒 gp.m.blocked = true if semasleep(-1) \u003c 0 { // 无限等待，如果中断，抛出异常 throw(\"runtime: unable to acquire - semaphore out of sync\") } gp.m.blocked = false // 唤醒了 return true default: // 意外的情况 throw(\"runtime: unexpected waitm - semaphore out of sync\") } } } ","date":"2022-09-07","objectID":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/:2:4","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/"},{"categories":["go runtime"],"content":"用户 g 调用的等待 func notetsleepg(n *note, ns int64) bool { gp := getg() if gp == gp.m.g0 { throw(\"notetsleepg on g0\") } semacreate(gp.m) entersyscallblock() ok := notetsleep_internal(n, ns, nil, 0) exitsyscall() return ok } ","date":"2022-09-07","objectID":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/:2:5","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6/"},{"categories":["go runtime"],"content":"对一次性事件进行睡眠和唤醒。在调用 notesleep 或者 notewakeup 之前，必须调用 noteclear 来初始化 note 。然后，一个线程可以调用 notesleep ，一个线程可以调用 notewakeup 一次，一点调用了 notewakeup ， notesleep 就会返回。后续调用 notesleep 将立即返回。之后的 noteclear 必须在之前的 notesleep 返回后调用。比如，不允许在 notewakeup 之后直接调用 noteclear。 notetsleep 和 notesleep 类似，但即使事件尚未发生，也会在给定的ns后唤醒。如果一个 goroutine 使用 notetsleep 提前唤醒，它必须等待调用 noteclear ，直到可以确定没有其他 goroutine 在调用 notewakeup。 notesleep 和 notetsleep 通常被 g0 调用。 notetsleepg 与 notetsleep 相似，但被用户 g 调用。 这是一家只能打包带走餐厅。 小明来买午饭，需要通过 noteclear 拿走一个叫号牌，通过 notesleep 告诉老板钱付过了，这个牌子的号码绑定的就是我的午餐。老板把饭做好了要叫号 notewakeup ，我们听到叫号，就去拿餐，阻塞就结束了。老板只会叫一次号，可能我们没听到叫号，但是我们过去柜台看的话，餐就在那里放着，上面也写着是多少号的餐。也就是 notewakeup 后，继续调用 notesleep 不会阻塞，立即返回。 今天比较着急，我只愿意等10分钟，超时小明上课就迟到了，奖学金就没有了，所以小明通过 notetsleep 告诉老板我很急，只能等10分钟，小明在10分钟拿到餐就是正常情况，但可能老板没做出来，小明就不等了，老板做出来之后，看了看号码牌，好像没人要这个餐了。小明课上完如果想起来自己还有个餐没拿，过来也是能直接拿到的。 ","date":"2022-09-07","objectID":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/:0:0","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"},{"categories":["go runtime"],"content":"结构 基于futex实现，key是一个uint32的值 基于sema实现，key是一个waitm type note struct { key uintptr } ","date":"2022-09-07","objectID":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/:1:0","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"},{"categories":["go runtime"],"content":"基于sema实现 ","date":"2022-09-07","objectID":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/:2:0","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"},{"categories":["go runtime"],"content":"初始化一次性通知或者清零一次性通知 // 就是给key设置成了0 func noteclear(n *note) { if GOOS == \"aix\" { atomic.Storeuintptr(\u0026n.key, 0) } else { n.key = 0 } } ","date":"2022-09-07","objectID":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/:2:1","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"},{"categories":["go runtime"],"content":"阻塞等待通知 func notesleep(n *note) { // 得到g gp := getg() // 如果 g 不是 g0，我们抛出错误 if gp != gp.m.g0 { throw(\"notesleep not on g0\") } // 初始化信号 semacreate(gp.m) // 如果 key 是 0 ，证明这是一个新初始化的 note // 我们让他存储当前 m 的地址 if !atomic.Casuintptr(\u0026n.key, 0, uintptr(unsafe.Pointer(gp.m))) { // 如果存储失败，证明 n.key 不是 0。 // 如果我们的已经调用了 notewakeup ， 导致 n.key 是 locked，那么我们就返回 // 如果 n.key 不是 locked 也不是锁定状态，我们这边还要阻塞的话，就报错。 if n.key != locked { throw(\"notesleep - waitm out of sync\") } return } // n.key 存储了 m 的地址，成功了，我们要让他等待 gp.m.blocked = true if *cgo_yield == nil { // 无限等待通知 semasleep(-1) } else { // 休眠一个任意但适中的间隔来轮询 libc 拦截器。 const ns = 10e6 // 如果这个时候 n.key 是 0 的话，证明被 wakeup 了 for atomic.Loaduintptr(\u0026n.key) == 0 { semasleep(ns) asmcgocall(*cgo_yield, nil) } } gp.m.blocked = false } 流程如下 现在 g0 要阻塞直到得到一个通知。 检查 note.key != 0 ，证明这个 note 已经被 wakeup(==locked) 或者 当前正在 sleep(==waitm) 中。 继续判断如果 note.key != locked ，也就是已经 sleep ，我们就报错，因为已经这个 note 上面正在睡眠等待，如果 note.key == locked 证明已经被唤醒，我们就直接返回，因为我们只会唤醒一次，后续调用 sleep 将不会进行阻塞 如果 note.key == 0 ，我们就将 m 的地址存入 note.key 中。开启信号量等待就好了 ","date":"2022-09-07","objectID":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/:2:2","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"},{"categories":["go runtime"],"content":"唤醒通知 func notewakeup(n *note) { var v uintptr for { // v 是我们 n.key 的值 v = atomic.Loaduintptr(\u0026n.key) // 如果 v 没有被其他线程修改，我们就让它的状态为locked if atomic.Casuintptr(\u0026n.key, v, locked) { break } } // 这里的 v 还是之前 key 的值 switch { case v == 0: // 如果之前 v == 0 证明之前就是一个解锁的状态，并且没有存储waitm，我们直接结束就好了，加锁已经完成 case v == locked: // 如果之前就是锁定的，我们就报错 throw(\"notewakeup - double wakeup\") default: // v 里面存储的是一个 waitm semawakeup((*m)(unsafe.Pointer(v))) } } ","date":"2022-09-07","objectID":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/:2:3","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"},{"categories":["go runtime"],"content":"带最大唤醒等待时间的等待 func notetsleep(n *note, ns int64) bool { gp := getg() if gp != gp.m.g0 { throw(\"notetsleep not on g0\") } semacreate(gp.m) return notetsleep_internal(n, ns, nil, 0) } func notetsleep_internal(n *note, ns int64, gp *g, deadline int64) bool { // gp 和 deadline 按逻辑来说是局部变量，但是为了存在调用者的栈中，我们写成了参数 // 这减少了 notetsleep_internal 的 nosplit 占用空间。 // 拿到 g ， 这个 g 是 g0 gp = getg() // 如果 n.key != 0 if !atomic.Casuintptr(\u0026n.key, 0, uintptr(unsafe.Pointer(gp.m))) { if n.key != locked { // 对已经阻塞的 note ，继续阻塞 throw(\"notetsleep - waitm out of sync\") } // 已经被唤醒的note return true } // 如果 n.key == 0，n.key = uintptr(unsafe.Pointer(gp.m)) // 当前 key 是要阻塞 m 的地址 if ns \u003c 0 { // 小于0，就是无限等待，跟上面逻辑一样 gp.m.blocked = true if *cgo_yield == nil { semasleep(-1) } else { // Sleep in arbitrary-but-moderate intervals to poll libc interceptors. const ns = 10e6 for semasleep(ns) \u003c 0 { asmcgocall(*cgo_yield, nil) } } gp.m.blocked = false return true } // 当 ns \u003e= 0，证明要有一个超时唤醒时间 deadline = nanotime() + ns for { gp.m.blocked = true if *cgo_yield != nil \u0026\u0026 ns \u003e 10e6 { ns = 10e6 } // semasleep(ns) \u003e= 0 代表着在规定时间内正常被唤醒，我们返回true if semasleep(ns) \u003e= 0 { gp.m.blocked = false // Acquired semaphore, semawakeup unregistered us. // Done. return true } // 小小休息一下，防止空耗cpu if *cgo_yield != nil { asmcgocall(*cgo_yield, nil) } gp.m.blocked = false // Interrupted or timed out. Still registered. Semaphore not acquired. ns = deadline - nanotime() // 等待超时了 if ns \u003c= 0 { break } // Deadline hasn't arrived. Keep sleeping. } // 我们超时拿不到信号量通知，要放弃了 for { // v 就是 waitm v := atomic.Loaduintptr(\u0026n.key) switch v { case uintptr(unsafe.Pointer(gp.m)): // 取消注册，返回，清空这个key，如果别人再来唤醒，也根本啥事不做了 if atomic.Casuintptr(\u0026n.key, v, 0) { return false } case locked: // 其他线程把note唤醒 gp.m.blocked = true if semasleep(-1) \u003c 0 { // 无限等待，如果中断，抛出异常 throw(\"runtime: unable to acquire - semaphore out of sync\") } gp.m.blocked = false // 唤醒了 return true default: // 意外的情况 throw(\"runtime: unexpected waitm - semaphore out of sync\") } } } ","date":"2022-09-07","objectID":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/:2:4","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"},{"categories":["go runtime"],"content":"用户 g 调用的等待 func notetsleepg(n *note, ns int64) bool { gp := getg() if gp == gp.m.g0 { throw(\"notetsleepg on g0\") } semacreate(gp.m) entersyscallblock() ok := notetsleep_internal(n, ns, nil, 0) exitsyscall() return ok } ","date":"2022-09-07","objectID":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/:2:5","tags":["runtime","go底层实现"],"title":"5. runtime之note一次性通知事件","uri":"/6.-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"},{"categories":["go runtime"],"content":"sync.Mutex 和 sync.Cond 都是对于协程 g 来说的，而 m.mOS.mutex 和 m.mOS.cond 是对线程 m 来说的，底层用法大概相同。 runtime.mutex 在 sema 的实现方案下（不同系统决定着实现方案的不同），底层依赖 m.mOS.mutex 和 m.mOS.cond 来加解锁操控 m ，这时候 mutex 中的 key 是 waitm ，一个等待的 m 的地址。 runtime.mutex 在 futex 的实现方案下，key 存储着锁的状态 ","date":"2022-09-04","objectID":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:0","tags":["runtime","go底层实现"],"title":"4. runtime之mutex线程锁的实现","uri":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["go runtime"],"content":"mutex基于信号sema的实现 ","date":"2022-09-04","objectID":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/:1:0","tags":["runtime","go底层实现"],"title":"4. runtime之mutex线程锁的实现","uri":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["go runtime"],"content":"信号的实现 func semacreate(mp *m) 为 m 创建信号量，如果它还没有的话。 func semasleep(ns int64) int32 最长阻塞ns纳秒来得到一个信号量，成功返回0，失败返回-1 func semawakeup(mp *m) 激活一个信号量 我们使用 semacreate 创建信号量之后，我们的信号量是空的，我们使用 semawakeup 信号量才会得到一个信号，我们使用 semasleep 是为了得到一个信号量，这个信号量是 semawakeup 发送过来的，如果在我们规定的时间拿不到信号量，或者程序中断，都会返回-1。 持有结构 // initialized 是否被初始化 // mutex 互斥锁 // cond 条件通知 // count 当前可直接获取的信号量数量 type mOS struct { initialized bool mutex pthreadmutex cond pthreadcond count int } semasleep 和 semawakeup 本质都是操作 count 的 semasleep 是 count - 1，如果 count == 0，就要等一个 semawakeup 给它加1 semawakeup 是 count + 1，如果 +1 后的 count 大于 0， 我们就要唤醒一个正在sleep semacreate // 给m.mOS的mutex和cond做初始化，如果已经被初始化了就算了 // 这里的mutex就是一个互斥体，防止多个线程并发访问修改数据导致出错的 func semacreate(mp *m) { // 如果已经被初始化，就不要再初始化了 if mp.initialized { return } mp.initialized = true // 初始化锁，互斥体 if err := pthread_mutex_init(\u0026mp.mutex, nil); err != 0 { throw(\"pthread_mutex_init\") } // 初始化条件通知 if err := pthread_cond_init(\u0026mp.cond, nil); err != 0 { throw(\"pthread_cond_init\") } } semasleep // 阻塞来获取信号 // ns如果小于0，它会一直阻塞等到能够获取信号为止 // ns如果大于等于0，它会最大阻塞ns这么长的时间来获取信号 // 成功返回0，失败返回其他 func semasleep(ns int64) int32 { var start int64 // 如果我们有最大耗时，我们就要先记录一下我们调用时候的时间，方便后面算花费了多长时间 if ns \u003e= 0 { start = nanotime() } // 得到m mp := getg().m // 上锁 pthread_mutex_lock(\u0026mp.mutex) for { // mp.count只有在唤醒一个信号的时候才会增加 if mp.count \u003e 0 { // 如果里面得到一个信号，我们就让它-- mp.count-- // 解锁就好了 pthread_mutex_unlock(\u0026mp.mutex) return 0 } // ns \u003e= 0 说明我们有一个耗时检测 if ns \u003e= 0 { // 判断一下我们当前花费的时间是不是超过我们的耗时了 spent := nanotime() - start if spent \u003e= ns { // 超过我们就解锁并返回-1 pthread_mutex_unlock(\u0026mp.mutex) return -1 } // t是一个时间量 var t timespec // 计算剩余t的值 t.setNsec(ns - spent) // 我们开始等待一个条件通知，让我们能继续执行，最长阻塞时间为t，这里面传入mutex也是为了上锁，里面好修改状态 err := pthread_cond_timedwait_relative_np(\u0026mp.cond, \u0026mp.mutex, \u0026t) // 如果超时，我们就返回-1 if err == _ETIMEDOUT { pthread_mutex_unlock(\u0026mp.mutex) return -1 } // 没有超时，我们就继续循环了 // 如果没有超时，证明cond得到了一个通知，我们的m.count是会++的，在上面会正常结束返回0 } else { // 如果我们让无限等待，且当前没有得到一个信号，我们就直接等通知就好了 pthread_cond_wait(\u0026mp.cond, \u0026mp.mutex) // 拿到通知后，再循环到上面count肯定也会大于0，就返回0就好了 } } } semawakeup // 唤醒一个信号，为我们的count++，并使用cond_signal进行通知 func semawakeup(mp *m) { // 加锁，因为要操作m了 pthread_mutex_lock(\u0026mp.mutex) mp.count++ if mp.count \u003e 0 { // 如果count\u003e0，代表持有信号量，我们就通知cond pthread_cond_signal(\u0026mp.cond) } pthread_mutex_unlock(\u0026mp.mutex) } ","date":"2022-09-04","objectID":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/:1:1","tags":["runtime","go底层实现"],"title":"4. runtime之mutex线程锁的实现","uri":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["go runtime"],"content":"mutex 的加解锁操作 // locked 用最低位是不是1来判断是否处于锁定状态 // active_spin 积极自旋的次数 // passive_spin 消极自旋的次数 // active_spin_cnt 用来自旋等待的 const ( locked uintptr = 1 active_spin = 4 active_spin_cnt = 30 passive_spin = 1 ) 获取锁 lock func lock(l *mutex) { // lockWithRank 在第三篇文章讲到了，就不说了 // 判断锁排名是否合法 lockWithRank(l, getLockRank(l)) } // 加锁操作 func lock2(l *mutex) { // 得到g gp := getg() // 判断m上锁的数量是不是异常的 if gp.m.locks \u003c 0 { throw(\"runtime·lock: lock count\") } // 给lock++ gp.m.locks++ // cas操作，判断l.key是不是0，如果是0，我们设置成locked，就结束了 if atomic.Casuintptr(\u0026l.key, 0, locked) { return } // 如果不是0，我们先初始化一下信号量 semacreate(gp.m) // 单核处理器不自旋，多核处理器自旋 spin := 0 if ncpu \u003e 1 { // 自旋4次 spin = active_spin } Loop: // 进入一个循环 for i := 0; ; i++ { // 获取key的值 v := atomic.Loaduintptr(\u0026l.key) // 判断key的最低位是不是0 if v\u0026locked == 0 { // 是0的话，证明可以直接加锁 // 我们尝试cas加锁，如果失败了，我们就让重新开始自旋 if atomic.Casuintptr(\u0026l.key, v, v|locked) { return } // 如果还是被锁定的，我们就重新自旋 i = 0 } if i \u003c spin { // i 如果小于自旋次数，调用procyield，资源消耗小 // 阻塞一下 procyield(active_spin_cnt) } else if i \u003c spin+passive_spin { // 如果i大于等于自旋次数，我们判断是不是还小于加上消极的自旋次数，就执行osyield，资源消耗大 // 阻塞一下 osyield() } else { // 不用自旋了，我们要给这个mutex进行入队等待了 // l.key 挂载的是等待这个锁的 m 的链表 // 通过 nextwaitm 来排队 for { // gp.m.nextwaitm 设置成的 v中的m，也就是原来的m // l.key设置成现在的m // 那么关系就是l.key是现在的m // l.key的m的nextwaitm是上一个m了 // 相当于入队到头部了 gp.m.nextwaitm = muintptr(v \u0026^ locked) // 如果v在中途没有被解锁，我们就把v设置成当前m的地址，最后一位设置成锁定中 if atomic.Casuintptr(\u0026l.key, v, uintptr(unsafe.Pointer(gp.m))|locked) { break } // 如果v被其他线程改变了，重新去一下v的新值（其他线程可能解锁了这个v） v = atomic.Loaduintptr(\u0026l.key) // 如果v当前处于解锁状态了 if v\u0026locked == 0 { // 继续外部循环了 continue Loop } } // 如果v锁定中，我们就挂起等待 if v\u0026locked != 0 { // 等待 semasleep(-1) i = 0 } } } } 当一个线程需要获取一个锁的时候，他执行流程如下 判断key的值等于0（也就是一个新锁），那么就直接设置为1锁定状态，并返回 如果key不是0，证明里面要么是1，要么是存了一个waitm，我们就要初始化信号锁（更底层，仅会初始化一次） 获取是否应该自旋和设置自旋次数 进入自旋也就是循环，此时key可能是1或者是一个waitm，waitm的最低位标志着当前锁的状态，我们判断最低位等于0，我们直接设置最低位为1，返回即可 如果设置最低位为1失败（其他线程抢先一步修改了），我们需要重新自旋 在上一步验证结束后，如果自旋次数还未循环结束，我们让处理器执行等待，后继续循环获取锁状态 如果自旋次数结束，无法获取到锁，我们就让当前m的nextwaitm指向key，也就是前面正在阻塞的m的地址，让我们的key存储当前m的地址 如果存储我们的m失败，证明当前锁已经被其他线程释放了，我们就继续判断，重新进入自旋状态 如果存储成功，我们就等待sema信号的通知即可 为什么m要通过那种方式设置，我们举个例子，他这个算法很巧妙。 地址与计算 备注 m 0x1000 m就是我们的线程地址 waitm 0x1001 (0x1000 \u0026^ 0x1) waitm就是我们的nextwaitm key 0x1001 (0x1000 | 0x1) key就是mutex里面存储的 getm 0x1000 (0x1001 \u0026^ 0x1) getm就是释放锁时从key里取到的m 释放锁 func unlock(l *mutex) { unlockWithRank(l) } func unlock2(l *mutex) { // 获取g gp := getg() var mp *m for { // 获取锁上存的key，也就是waitm以及锁定状态 v := atomic.Loaduintptr(\u0026l.key) // 如果锁定中，直接解锁 if v == locked { // cas操作解锁 if atomic.Casuintptr(\u0026l.key, locked, 0) { break } } else { // 当前v不是单纯的锁定状态，里面存储了m信息 // 取到m的指针 mp = muintptr(v \u0026^ locked).ptr() // 让我们的key指向下一个等待的m身上 if atomic.Casuintptr(\u0026l.key, v, uintptr(mp.nextwaitm)) { // 唤醒mp semawakeup(mp) break } } } // 解锁成功 gp.m.locks-- if gp.m.locks \u003c 0 { throw(\"runtime·unlock: lock count\") } // 如果m上没有锁了，就恢复抢占请求 if gp.m.locks == 0 \u0026\u0026 gp.preempt { // restore the preemption request in case we've cleared it in newstack gp.stackguard0 = stackPreempt } } ","date":"2022-09-04","objectID":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/:1:2","tags":["runtime","go底层实现"],"title":"4. runtime之mutex线程锁的实现","uri":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["go runtime"],"content":"mutex基于futex的实现 ","date":"2022-09-04","objectID":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:0","tags":["runtime","go底层实现"],"title":"4. runtime之mutex线程锁的实现","uri":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["go runtime"],"content":"获取锁 func lock(l *mutex) { lockWithRank(l, getLockRank(l)) } func lock2(l *mutex) { // 拿到g gp := getg() if gp.m.locks \u003c 0 { throw(\"runtime·lock: lock count\") } gp.m.locks++ // 把l.key设置成mutex_locked v := atomic.Xchg(key32(\u0026l.key), mutex_locked) // 判断原来l.key是不是解锁状态，拿到锁了 if v == mutex_unlocked { return } // wait 现在是 MUTEX_LOCKED 或者 MUTEX_SLEEPING状态 wait := v spin := 0 if ncpu \u003e 1 { spin = active_spin } for { // 积极自旋，再次尝试解锁 for i := 0; i \u003c spin; i++ { // 如果其他线程把锁释放了，我们这边就能拿到了，并且把锁状态，设置成我们上面本来的状态 for l.key == mutex_unlocked { if atomic.Cas(key32(\u0026l.key), mutex_unlocked, wait) { return } } procyield(active_spin_cnt) } // 消极自旋，与上面相同，就是换成了osyield for i := 0; i \u003c passive_spin; i++ { for l.key == mutex_unlocked { if atomic.Cas(key32(\u0026l.key), mutex_unlocked, wait) { return } } osyield() } // 我们再获取一次，获取到了就ok，再挂载到futex的时候一定是sleeping状态 v = atomic.Xchg(key32(\u0026l.key), mutex_sleeping) if v == mutex_unlocked { return } // 来到这块，证明我们的锁获取不到了，我们要去睡眠了 wait = mutex_sleeping futexsleep(key32(\u0026l.key), mutex_sleeping, -1) } } ","date":"2022-09-04","objectID":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:1","tags":["runtime","go底层实现"],"title":"4. runtime之mutex线程锁的实现","uri":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["go runtime"],"content":"释放锁 func unlock(l *mutex) { unlockWithRank(l) } func unlock2(l *mutex) { // 把锁设置成mutex_unlocked v := atomic.Xchg(key32(\u0026l.key), mutex_unlocked) // 判断原来是不是就是解锁状态 if v == mutex_unlocked { throw(\"unlock of unlocked lock\") } // 如果锁在睡眠中，我们就唤醒一个 if v == mutex_sleeping { futexwakeup(key32(\u0026l.key), 1) } gp := getg() gp.m.locks-- if gp.m.locks \u003c 0 { throw(\"runtime·unlock: lock count\") } if gp.m.locks == 0 \u0026\u0026 gp.preempt { // restore the preemption request in case we've cleared it in newstack gp.stackguard0 = stackPreempt } } ","date":"2022-09-04","objectID":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:2","tags":["runtime","go底层实现"],"title":"4. runtime之mutex线程锁的实现","uri":"/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["go runtime"],"content":"在runtime.mutex中内嵌了一个叫lockRankStruct的结构体，看名字我们就知道是做锁排名的。mutex我们在runtime系列的第四篇文章讲到。 它其实很简单，一开始我们的锁，只能有一个人持有，等他释放了，其他人才能来获取锁。 现在有了这个锁排名机制，当我们要来获取锁的时候，我们首先看这个锁有没有被持有，最后来的一个持有这个锁的人的等级是不是比我们低，如果比我们低的话，我们要去查一下我们的表，看看当他持有锁的时候，我们能不能继续获取锁。如果能，我们就能直接获取锁。 这个静态排名检查功能，我们要在GOEXPERIMENT开启staticklockranking才有效 ","date":"2022-09-04","objectID":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/:0:0","tags":["runtime","go底层实现"],"title":"3. runtime之lockRank锁排名机制","uri":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/"},{"categories":["go runtime"],"content":"排名结构 // 锁的排名本质就是一个数字 type lockRank int // 包装了一个排名结构，里面的pad是用来填充，让lockRankStruct是8字节的 type lockRankStruct struct { rank lockRank pad int } // 这就是我们查询是否能同时持有锁的一个表 // 一维数组表示不同的锁，里面存着它们的等级，刚好它们的下标也是它们的等级 // 二维数组就是当我们要持有锁的时候查询表来看看前一个是不是在自己的合法锁里面，如果不在，我们也不能同时持有这两个锁 var lockPartialOrder [][]lockRank = [][]lockRank{ lockRankDummy: {}, lockRankSysmon: {}, lockRankScavenge: {lockRankSysmon}, lockRankForcegc: {lockRankSysmon}, lockRankSweepWaiters: {}, lockRankAssistQueue: {}, lockRankCpuprof: {}, lockRankSweep: {}, lockRankPollDesc: {}, lockRankSched: {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankCpuprof, lockRankSweep, lockRankPollDesc}, lockRankDeadlock: {lockRankDeadlock}, lockRankAllg: {lockRankSysmon, lockRankSched}, lockRankAllp: {lockRankSysmon, lockRankSched}, lockRankTimers: {lockRankSysmon, lockRankScavenge, lockRankPollDesc, lockRankSched, lockRankAllp, lockRankTimers}, lockRankItab: {}, lockRankReflectOffs: {lockRankItab}, lockRankHchan: {lockRankScavenge, lockRankSweep, lockRankHchan}, lockRankTraceBuf: {lockRankSysmon, lockRankScavenge}, lockRankFin: {lockRankSysmon, lockRankScavenge, lockRankSched, lockRankAllg, lockRankTimers, lockRankReflectOffs, lockRankHchan, lockRankTraceBuf}, lockRankNotifyList: {}, lockRankTraceStrings: {lockRankTraceBuf}, lockRankMspanSpecial: {lockRankSysmon, lockRankScavenge, lockRankAssistQueue, lockRankCpuprof, lockRankSweep, lockRankSched, lockRankAllg, lockRankAllp, lockRankTimers, lockRankItab, lockRankReflectOffs, lockRankHchan, lockRankTraceBuf, lockRankNotifyList, lockRankTraceStrings}, lockRankProf: {lockRankSysmon, lockRankScavenge, lockRankAssistQueue, lockRankCpuprof, lockRankSweep, lockRankSched, lockRankAllg, lockRankAllp, lockRankTimers, lockRankItab, lockRankReflectOffs, lockRankHchan, lockRankTraceBuf, lockRankNotifyList, lockRankTraceStrings}, lockRankGcBitsArenas: {lockRankSysmon, lockRankScavenge, lockRankAssistQueue, lockRankCpuprof, lockRankSched, lockRankAllg, lockRankTimers, lockRankItab, lockRankReflectOffs, lockRankHchan, lockRankTraceBuf, lockRankNotifyList, lockRankTraceStrings}, lockRankRoot: {}, lockRankTrace: {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankAssistQueue, lockRankSweep, lockRankSched, lockRankHchan, lockRankTraceBuf, lockRankTraceStrings, lockRankRoot}, lockRankTraceStackTab: {lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankSweep, lockRankSched, lockRankAllg, lockRankTimers, lockRankHchan, lockRankTraceBuf, lockRankFin, lockRankNotifyList, lockRankTraceStrings, lockRankRoot, lockRankTrace}, lockRankNetpollInit: {lockRankTimers}, lockRankRwmutexW: {}, lockRankRwmutexR: {lockRankSysmon, lockRankRwmutexW}, lockRankSpanSetSpine: {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankAssistQueue, lockRankCpuprof, lockRankSweep, lockRankPollDesc, lockRankSched, lockRankAllg, lockRankAllp, lockRankTimers, lockRankItab, lockRankReflectOffs, lockRankHchan, lockRankTraceBuf, lockRankNotifyList, lockRankTraceStrings}, lockRankGscan: {lockRankSysmon, lockRankScavenge, lockRankForcegc, lockRankSweepWaiters, lockRankAssistQueue, lockRankCpuprof, lockRankSweep, lockRankPollDesc, lockRankSched, lockRankTimers, lockRankItab, lockRankReflectOffs, lockRankHchan, lockRankTraceBuf, lockRankFin, lockRankNotifyList, lockRankTraceStrings, lockRankProf, lockRankGcBitsArenas, lockRankRoot, lockRankTrace, lockRankTraceStackTab, lockRankNetpollInit, lockRankSpanSetSpine}, lockRankStackpool: {lockRankSysmon, lockRankScavenge, lockRankSweepWaiters, lockRankAssistQueue, lockRankCpuprof, lockRankSweep, lockRankPollDesc, lockRankSched, lockRankTimers, lockRankItab, lockRankReflectOffs, lockRankHchan, lockRankTraceBuf, lockRankFin, lockRankNotifyList, lockRankTraceStrings, lockRankProf, lockRankGcBitsArenas, lockRankRoot, lockRankTrace, lockRankTraceStackTab, lockRankNetpollInit, lockRankRwmutexR, lockRankSpanSetSpine, lockRankGscan}, lockRankStackLarge: {lockRankSysmon, loc","date":"2022-09-04","objectID":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/:1:0","tags":["runtime","go底层实现"],"title":"3. runtime之lockRank锁排名机制","uri":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/"},{"categories":["go runtime"],"content":"锁排名的初始化 // 其实就是给mutex上加上了这个排名数字 func lockInit(l *mutex, rank lockRank) { l.rank = rank } ","date":"2022-09-04","objectID":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/:2:0","tags":["runtime","go底层实现"],"title":"3. runtime之lockRank锁排名机制","uri":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/"},{"categories":["go runtime"],"content":"直接获取锁上面的排名 func getLockRank(l *mutex) lockRank { return l.rank } ","date":"2022-09-04","objectID":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/:3:0","tags":["runtime","go底层实现"],"title":"3. runtime之lockRank锁排名机制","uri":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/"},{"categories":["go runtime"],"content":"带排名加锁 就是检查这个排名的锁能不能合法的lock，如果可以就lock // 第二个参数就是我们锁排名 func lockWithRank(l *mutex, rank lockRank) { if l == \u0026debuglock || l == \u0026paniclk { // 这俩东西不要做排名 // debuglock是调试输出我们当前m上面持有锁和排名信息的 // paniclk同理也差不多，是异常错误后执行的 // lock2和unlock2都是和mutex有关的，第四篇文章讲到 lock2(l) return } // 如果rank == 0，我们的rank就是一个数值最大的锁，它只会判断前一个锁是不是lockRankLeafRank来决定能不能获取锁 if rank == 0 { rank = lockRankLeafRank } // 获取我们执行的g gp := getg() // 切换系统栈，也就是g0的栈中执行下面 systemstack(func() { // i是我们gp上面持有的锁信息长度 i := gp.m.locksHeldLen // 如果我们locksHeldLen显示的长度\u003e=10，那么就报错 // m 持有最多 10 个锁，由锁排名代码维护。 if i \u003e= len(gp.m.locksHeld) { throw(\"too many locks held concurrently for rank checking\") } // 把这个锁信息（排名和锁地址）记录到m上 gp.m.locksHeld[i].rank = rank gp.m.locksHeld[i].lockAddr = uintptr(unsafe.Pointer(l)) gp.m.locksHeldLen++ // i==0的话，证明是第一个锁，直接放上去就好了，不用检查的 // i \u003e 0的话，证明不是第一个锁，我们就要判断我们新锁能不能加入进来 if i \u003e 0 { checkRanks(gp, gp.m.locksHeld[i-1].rank, rank) } // 如果能加入进来，我们就上锁了 lock2(l) }) } 相同的还有一个函数func acquireLockRank(rank lockRank)他只是判断排名是否合法，然后把排名信息挂载到m上去，不进行锁操作，因为它也没给传一个锁，内部逻辑其实是一样的 ","date":"2022-09-04","objectID":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/:4:0","tags":["runtime","go底层实现"],"title":"3. runtime之lockRank锁排名机制","uri":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/"},{"categories":["go runtime"],"content":"真正的锁排名检查机制 func checkRanks(gp *g, prevRank, rank lockRank) { // 一开始设置我们的rankOK为false rankOK := false // prevRank是前一个锁的等级，rank是我们现在要来的锁等级 if rank \u003c prevRank { // 我们新来的锁比前一个锁的等级低，我们不能上锁 rankOK = false } else if rank == lockRankLeafRank { // 我们新来的锁，是一个最大锁，我们就判断前一个不是最大锁就行了 rankOK = prevRank \u003c lockRankLeafRank } else { // 来到这块证明我们的新来的锁比前一个锁等级要高，我们得查表看看他们能不能一起使用 // lockPartialOrder是一个二维数组，我们在上面看到过 list := lockPartialOrder[rank] for _, entry := range list { // 判断我们的前一个锁，有没有出现在自己的合法列表里面，如果出现了那么就是true if entry == prevRank { rankOK = true break } } } // 如果没出现，就打印调试信息，报错就好了 if !rankOK { printlock() println(gp.m.procid, \" ======\") printHeldLocks(gp) throw(\"lock ordering problem\") } } ","date":"2022-09-04","objectID":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/:5:0","tags":["runtime","go底层实现"],"title":"3. runtime之lockRank锁排名机制","uri":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/"},{"categories":["go runtime"],"content":"释放锁以及排名信息 如果我们开启staticklockranking功能后，我们的解锁需要把m上面挂在的锁信息也给删一下 func unlockWithRank(l *mutex) { if l == \u0026debuglock || l == \u0026paniclk { // 与lockWithRank同理 unlock2(l) return } // 下面就是简单的摘掉一个锁的过程 gp := getg() systemstack(func() { found := false for i := gp.m.locksHeldLen - 1; i \u003e= 0; i-- { if gp.m.locksHeld[i].lockAddr == uintptr(unsafe.Pointer(l)) { // 我们要的锁找到了 found = true copy(gp.m.locksHeld[i:gp.m.locksHeldLen-1], gp.m.locksHeld[i+1:gp.m.locksHeldLen]) gp.m.locksHeldLen-- break } } // 没找到的话，就调试，还有报错 if !found { println(gp.m.procid, \":\", l.rank.String(), l.rank, l) throw(\"unlock without matching lock acquire\") } // 解锁 unlock2(l) }) } 相同的还有一个函数func releaseLockRank(rank lockRank)他只是释放m上面绑定的一个排名信息，锁地址是0的一个玩意。与acquireLockRank对照 ","date":"2022-09-04","objectID":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/:6:0","tags":["runtime","go底层实现"],"title":"3. runtime之lockRank锁排名机制","uri":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/"},{"categories":["go runtime"],"content":"判断排名合不合法 不做任何操作也不往m上挂载锁信息 // lockWithRankMayAcquire 判断锁排名是否合法，不合法就报错 func lockWithRankMayAcquire(l *mutex, rank lockRank) { // 拿到g gp := getg() // 判断有没有锁 if gp.m.locksHeldLen == 0 { // 没有锁，不可能出现锁排序出错问题 return } // 切换系统栈 systemstack(func() { i := gp.m.locksHeldLen if i \u003e= len(gp.m.locksHeld) { throw(\"too many locks held concurrently for rank checking\") } // 这边就是临时挂载上去，然后做了一个判断 gp.m.locksHeld[i].rank = rank gp.m.locksHeld[i].lockAddr = uintptr(unsafe.Pointer(l)) gp.m.locksHeldLen++ checkRanks(gp, gp.m.locksHeld[i-1].rank, rank) gp.m.locksHeldLen-- }) } ","date":"2022-09-04","objectID":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/:7:0","tags":["runtime","go底层实现"],"title":"3. runtime之lockRank锁排名机制","uri":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/"},{"categories":["go runtime"],"content":"判断g是否持有锁l // 判断m有没有持有锁l func checkLockHeld(gp *g, l *mutex) bool { for i := gp.m.locksHeldLen - 1; i \u003e= 0; i-- { if gp.m.locksHeld[i].lockAddr == uintptr(unsafe.Pointer(l)) { return true } } return false } func assertLockHeld(l *mutex)省略了一个g参数，这个里面是获取当前执行的g的m func assertRankHeld(r lockRank)这个和上面的逻辑差不多，你们下去自己看，就是判断m是否持有这个排名 ","date":"2022-09-04","objectID":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/:8:0","tags":["runtime","go底层实现"],"title":"3. runtime之lockRank锁排名机制","uri":"/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/"},{"categories":["go runtime"],"content":"假如我们去餐馆吃饭，下单后会给你一个编号，然后你等着叫号拿菜就好了。 我们去下单了，把我们就记录到系统里面了wait+1 叫号Signal，他会按照notify序号来叫号，如果叫到你了，你就可以来拿餐了，然后它还会把notify序号加一 全部都做好了Broadcast，把所有人都叫过来拿餐，把notify序号更新成最大的出单号 head就是指向我们排队的第一个人(sudog) tail就是我们队伍的最后一个人(sudog) 排队是通过sudog.next进行连接的 ","date":"2022-09-03","objectID":"/2.-runtime%E4%B9%8Bnotifylist%E6%9D%A1%E4%BB%B6%E5%94%A4%E9%86%92/:0:0","tags":["runtime","go底层实现"],"title":"2. runtime之notifyList条件唤醒","uri":"/2.-runtime%E4%B9%8Bnotifylist%E6%9D%A1%E4%BB%B6%E5%94%A4%E9%86%92/"},{"categories":["go runtime"],"content":"结构 type notifyList struct { wait uint32 notify uint32 lock mutex head *sudog tail *sudog } wait 当前出单时的序号 notify 当前正在出餐的序号，餐出好后，会按照这个序号叫号 lock 锁 head 当前排队等餐人的第一个 tail 当前排队等餐人的最后一个 ","date":"2022-09-03","objectID":"/2.-runtime%E4%B9%8Bnotifylist%E6%9D%A1%E4%BB%B6%E5%94%A4%E9%86%92/:1:0","tags":["runtime","go底层实现"],"title":"2. runtime之notifyList条件唤醒","uri":"/2.-runtime%E4%B9%8Bnotifylist%E6%9D%A1%E4%BB%B6%E5%94%A4%E9%86%92/"},{"categories":["go runtime"],"content":"获取出餐号 func notifyListAdd(l *notifyList) uint32 { // 给wait加上1，返回原来wait的序号，wait加完1之后就是下一次点单要出的号 return atomic.Xadd(\u0026l.wait, 1) - 1 } ","date":"2022-09-03","objectID":"/2.-runtime%E4%B9%8Bnotifylist%E6%9D%A1%E4%BB%B6%E5%94%A4%E9%86%92/:2:0","tags":["runtime","go底层实现"],"title":"2. runtime之notifyList条件唤醒","uri":"/2.-runtime%E4%B9%8Bnotifylist%E6%9D%A1%E4%BB%B6%E5%94%A4%E9%86%92/"},{"categories":["go runtime"],"content":"人去排队 func notifyListWait(l *notifyList, t uint32) { // 加锁 lockWithRank(\u0026l.lock, lockRankNotifyList) // 我们拿着单号去排队，先看一下我们的单号是不是叫号系统当前应该叫的号小，如果小的话，肯定叫不到我们，我们走就好了 if less(t, l.notify) { unlock(\u0026l.lock) return } // 新建一个sudog s := acquireSudog() // 获取当前要阻塞的g s.g = getg() // 把我们的t放到sudog s.ticket = t // 如果队伍没有尾巴，那我们就是一个 if l.tail == nil { // 没有尾巴，也就是没人排队，我就来当头 l.head = s } else { l.tail.next = s } // 每次排队肯定会设置尾巴的 l.tail = s // 排完队，我们就等着吧，可以站在原地休息一会 goparkunlock(\u0026l.lock, waitReasonSyncCondWait, traceEvGoBlockCond, 3) // 执行到这里，就证明，叫到我们了 if t0 != 0 { blockevent(s.releasetime-t0, 2) } // 释放sudog releaseSudog(s) } ","date":"2022-09-03","objectID":"/2.-runtime%E4%B9%8Bnotifylist%E6%9D%A1%E4%BB%B6%E5%94%A4%E9%86%92/:3:0","tags":["runtime","go底层实现"],"title":"2. runtime之notifyList条件唤醒","uri":"/2.-runtime%E4%B9%8Bnotifylist%E6%9D%A1%E4%BB%B6%E5%94%A4%E9%86%92/"},{"categories":["go runtime"],"content":"叫号，出了一个餐了 func notifyListNotifyOne(l *notifyList) { // 判断我们当前要出单的号码，和我们轮到叫的号码是不是想等的，如果想等，那就没人排队，就没有单子在做 if atomic.Load(\u0026l.wait) == atomic.Load(\u0026l.notify) { return } // 加锁 lockWithRank(\u0026l.lock, lockRankNotifyList) // t就有我们需要通知到的序号 t := l.notify // 如果t是我们将要出单的序号的话，那么肯定就没有g在等待我们出餐 if t == atomic.Load(\u0026l.wait) { unlock(\u0026l.lock) return } // 更新一下notify的序号 atomic.Store(\u0026l.notify, t+1) // 在队伍里面找到第一个人，然后给他通知说可以了 // 并且，让队伍往前走一步 for p, s := (*sudog)(nil), l.head; s != nil; p, s = s, s.next { if s.ticket == t { // 找到我们要通知的sudog了 n := s.next if p != nil { p.next = n } else { l.head = n } if n == nil { l.tail = p } unlock(\u0026l.lock) s.next = nil // 通知餐好了，你可以来拿餐了 readyWithTime(s, 4) return } } unlock(\u0026l.lock) } ","date":"2022-09-03","objectID":"/2.-runtime%E4%B9%8Bnotifylist%E6%9D%A1%E4%BB%B6%E5%94%A4%E9%86%92/:4:0","tags":["runtime","go底层实现"],"title":"2. runtime之notifyList条件唤醒","uri":"/2.-runtime%E4%B9%8Bnotifylist%E6%9D%A1%E4%BB%B6%E5%94%A4%E9%86%92/"},{"categories":["go runtime"],"content":"唤醒所有 func notifyListNotifyAll(l *notifyList) { if atomic.Load(\u0026l.wait) == atomic.Load(\u0026l.notify) { return } lockWithRank(\u0026l.lock, lockRankNotifyList) // 把队伍记载了临时的s里面 s := l.head // 把队伍清空了 l.head = nil l.tail = nil // 更新一下叫号 atomic.Store(\u0026l.notify, atomic.Load(\u0026l.wait)) unlock(\u0026l.lock) // 把队伍里面所有人都通知一遍，菜好了 for s != nil { next := s.next s.next = nil readyWithTime(s, 4) s = next } } ","date":"2022-09-03","objectID":"/2.-runtime%E4%B9%8Bnotifylist%E6%9D%A1%E4%BB%B6%E5%94%A4%E9%86%92/:5:0","tags":["runtime","go底层实现"],"title":"2. runtime之notifyList条件唤醒","uri":"/2.-runtime%E4%B9%8Bnotifylist%E6%9D%A1%E4%BB%B6%E5%94%A4%E9%86%92/"},{"categories":["go runtime"],"content":"假如我们有一个宰🐷厂sema，里面有很多的危险工具，比如刀。 我们有好几个仓库（不同的addr），里面放着各种各样的刀，每个仓库它们都记录着有多少把刀addr存储的uint32数。 它们可能好几个仓库里的比较近，会有一个大门统一排队管理（它们会选择到同一个seamRoot）。 这个大门上面记录了当前有多少人在排队nwait，记录了排队情况treap 大门外面要让去不同的仓库的人排着不同的队伍，这些队伍的头部通过parent、next、prev组成了一个平衡二叉树 队伍里面所有人就是一个链表，通过waitlink进行连接，每个人的waittail记录着它们队伍的最后一个人 大门的treap上面只记录了每个队伍的第一个人 ","date":"2022-09-03","objectID":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/:0:0","tags":["runtime","go底层实现"],"title":"1. runtime之sema信号锁","uri":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/"},{"categories":["go runtime"],"content":"获取门锁时传递的uint32地址有什么用 我们在获取和归还刀的时候，都需要从一个uint32的地址上进行寻找锁，这个uint32数值代表着当前仓库里面的刀的数量，uint32的地址就是仓库地址。 ","date":"2022-09-03","objectID":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/:1:0","tags":["runtime","go底层实现"],"title":"1. runtime之sema信号锁","uri":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/"},{"categories":["go runtime"],"content":"我们通过仓库地址找大门 // 我们规划了251个大门，从semtable0～250下标 const semTabSize = 251 // semtable长度 // 每个semtable，里面就是一个大门 var semtable [semTabSize]struct { // semaRoot就是大门 root semaRoot pad [cpu.CacheLinePadSize - unsafe.Sizeof(semaRoot{})]byte } // 下面就是根据我们传进来的地址找大门的一个方法 func semroot(addr *uint32) *semaRoot { return \u0026semtable[(uintptr(unsafe.Pointer(addr))\u003e\u003e3)%semTabSize].root } ","date":"2022-09-03","objectID":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/:2:0","tags":["runtime","go底层实现"],"title":"1. runtime之sema信号锁","uri":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/"},{"categories":["go runtime"],"content":"仓库大门长啥样 // semaRoot 就是仓库大门，里面记录着门口等了多少人，排队的队伍，以及队伍里面的人是要去哪个小仓库 type semaRoot struct { lock mutex treap *sudog // 大门进去会有很多小仓库，不同仓库排队队伍的第一个人 nwait uint32 // 等待的人的数量 } ","date":"2022-09-03","objectID":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/:3:0","tags":["runtime","go底层实现"],"title":"1. runtime之sema信号锁","uri":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/"},{"categories":["go runtime"],"content":"简单的拿一个刀 // 我们获取刀的时候，如果仓库里面还有，那就直接拿走，并返回true，不然就返回false func cansemacquire(addr *uint32) bool { for { v := atomic.Load(addr) if v == 0 { return false } if atomic.Cas(addr, v, v-1) { return true } } } ","date":"2022-09-03","objectID":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/:4:0","tags":["runtime","go底层实现"],"title":"1. runtime之sema信号锁","uri":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/"},{"categories":["go runtime"],"content":"要去拿一个刀 // 这个是获取刀的真实的逻辑 func semacquire1(addr *uint32, lifo bool, profile semaProfileFlags, skipframes int) { // 是谁来获取，是gp gp := getg() if gp != gp.m.curg { throw(\"semacquire not on the G stack\") } // 简单的case，就是仓库里面还有刀 if cansemacquire(addr) { return } // 下面就是这4步 // 1. 增加大门口等待排队的数量 // 2. 尝试再去看一下我们的仓库里面还有没有刀，如果有，可能是有人归还了，我们就直接拿着走 // 3. 去排队了 // 4. 休眠 // 新建一个sudog s := acquireSudog() // 获取大门信息 root := semroot(addr) t0 := int64(0) s.releasetime = 0 s.acquiretime = 0 // s的ticket是0 s.ticket = 0 for { // 大门加锁 lockWithRank(\u0026root.lock, lockRankRoot) // 给大门等待人数量上加1 atomic.Xadd(\u0026root.nwait, 1) // 判断他要去的仓库里面还有没有刀 if cansemacquire(addr) { atomic.Xadd(\u0026root.nwait, -1) unlock(\u0026root.lock) break } // 暂时里面没有东西，我们等着吧，就要去排队 root.queue(addr, s, lifo) // gopark阻塞这个g goparkunlock(\u0026root.lock, waitReasonSemacquire, traceEvGoBlockSync, 4+skipframes) // 这边是唤醒了这个g // 我们的票据不是0的话，或者我们仓库里面有刀的话，就可以得到执行 if s.ticket != 0 || cansemacquire(addr) { break } } // 释放sudog releaseSudog(s) } ","date":"2022-09-03","objectID":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/:5:0","tags":["runtime","go底层实现"],"title":"1. runtime之sema信号锁","uri":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/"},{"categories":["go runtime"],"content":"刀没直接拿到，要去排队等 // 这个就是给semaRoot.treap上面进行排队 func (root *semaRoot) queue(addr *uint32, s *sudog, lifo bool) { // 拿到我们要排队的人 s.g = getg() // 存一下它要去的仓库在哪 s.elem = unsafe.Pointer(addr) // 等我们下面再给他说，它该拍到哪里，前一个队伍是谁，后一个队伍是谁 s.next = nil s.prev = nil var last *sudog // pt一开始就是第一个队伍第一个人 pt := \u0026root.treap // for循环，在每个队列里面找我们的小仓库是那个队伍 for t := *pt; t != nil; t = *pt { if t.elem == unsafe.Pointer(addr) { // t就是我们小仓库的排队信息 if lifo { // lifo是说，后入队的，先执行，排到最前面 // prev和next都是队伍第一个人要知道的 // 同一个队伍的不同人是通过waitlink连接的 // 队伍的每个人都能通过waittail知道最后一个人的信息 *pt = s s.ticket = t.ticket s.acquiretime = t.acquiretime s.parent = t.parent s.prev = t.prev s.next = t.next if s.prev != nil { s.prev.parent = s } if s.next != nil { s.next.parent = s } // Add t first in s's wait list. s.waitlink = t s.waittail = t.waittail if s.waittail == nil { s.waittail = t } t.parent = nil t.prev = nil t.next = nil t.waittail = nil } else { // 把人排队队伍的最后面 if t.waittail == nil { t.waitlink = s } else { t.waittail.waitlink = s } t.waittail = s s.waitlink = nil } return } // 倒是第二个找到的队伍 last = t // 因为我们存储的时候是这样存的，所以我们这边也是这样找的 if uintptr(unsafe.Pointer(addr)) \u003c uintptr(t.elem) { pt = \u0026t.prev } else { pt = \u0026t.next } } // ticket很经常和0进行比对，所以我们让最后1位为1的话，肯定就不是0 s.ticket = fastrand() | 1 s.parent = last *pt = s // 修复这个平衡二叉树，让这个树继续满足条件 for s.parent != nil \u0026\u0026 s.parent.ticket \u003e s.ticket { if s.parent.prev == s { root.rotateRight(s.parent) } else { if s.parent.next != s { panic(\"semaRoot queue\") } root.rotateLeft(s.parent) } } } ","date":"2022-09-03","objectID":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/:6:0","tags":["runtime","go底层实现"],"title":"1. runtime之sema信号锁","uri":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/"},{"categories":["go runtime"],"content":"归还一个刀，让其他的人也能去用了 // 归还一个刀 func semrelease1(addr *uint32, handoff bool, skipframes int) { // 找到大门 root := semroot(addr) // 给仓库里面还一把刀 atomic.Xadd(addr, 1) // 如果没有人在等，就直接结束就好了 if atomic.Load(\u0026root.nwait) == 0 { return } // 有人在等呢 // 加锁 lockWithRank(\u0026root.lock, lockRankRoot) // 在判断一下，可能有其他人过来了 if atomic.Load(\u0026root.nwait) == 0 { unlock(\u0026root.lock) return } // 我们找一个sudog让他出来拿刀工作 s, t0 := root.dequeue(addr) // 如果找到了，就让大门的等待数量-1 if s != nil { atomic.Xadd(\u0026root.nwait, -1) } // 解锁大门 unlock(\u0026root.lock) if s != nil { // s.ticket != 0 证明这个ticket不太合法 // 也就是说sudog要执行，必须要把票清空 if s.ticket != 0 { throw(\"corrupted semaphore ticket\") } // 我们再去判断一下能不能拿到刀，能拿到的话，ticket=1 if handoff \u0026\u0026 cansemacquire(addr) { s.ticket = 1 } // 恢复我们的g，将我们的g放在p的runnext readyWithTime(s, 5+skipframes) // 如果ticket是1，我们的g的m上没上锁的话 if s.ticket == 1 \u0026\u0026 getg().m.locks == 0 { // 如果是饥饿模式，我们直接切换到g执行，不要等了 goyield() } } } ","date":"2022-09-03","objectID":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/:7:0","tags":["runtime","go底层实现"],"title":"1. runtime之sema信号锁","uri":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/"},{"categories":["go runtime"],"content":"其他人还刀，通知我们来拿刀 func (root *semaRoot) dequeue(addr *uint32) (found *sudog, now int64) { // ps就是门锁的第一个队伍的第一个人 ps := \u0026root.treap s := *ps for ; s != nil; s = *ps { if s.elem == unsafe.Pointer(addr) { // 找到我们的队伍了 goto Found } if uintptr(unsafe.Pointer(addr)) \u003c uintptr(s.elem) { ps = \u0026s.prev } else { ps = \u0026s.next } } // 没找到我们的队伍 return nil, 0 Found: // 删除我们的sudog if t := s.waitlink; t != nil { *ps = t t.ticket = s.ticket t.parent = s.parent t.prev = s.prev if t.prev != nil { t.prev.parent = t } t.next = s.next if t.next != nil { t.next.parent = t } if t.waitlink != nil { t.waittail = s.waittail } else { t.waittail = nil } t.acquiretime = now s.waitlink = nil s.waittail = nil } else { // 删除这个队伍，因为没有人排队了，还要修复一下平衡二叉树 for s.next != nil || s.prev != nil { if s.next == nil || s.prev != nil \u0026\u0026 s.prev.ticket \u003c s.next.ticket { root.rotateRight(s) } else { root.rotateLeft(s) } } // Remove s, now a leaf. if s.parent != nil { if s.parent.prev == s { s.parent.prev = nil } else { s.parent.next = nil } } else { root.treap = nil } } s.parent = nil s.elem = nil s.next = nil s.prev = nil s.ticket = 0 return s, now } ","date":"2022-09-03","objectID":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/:8:0","tags":["runtime","go底层实现"],"title":"1. runtime之sema信号锁","uri":"/1.-runtime%E4%B9%8Bsema%E4%BF%A1%E5%8F%B7%E9%94%81/"}]