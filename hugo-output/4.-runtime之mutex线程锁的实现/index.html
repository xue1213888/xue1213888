<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>4. runtime之mutex线程锁的实现 - 🏠 Xsc Study Notes</title><meta name=Description content="为了更好的学习总结回顾，建立了这个blog，这里是我的学习笔记。"><meta property="og:title" content="4. runtime之mutex线程锁的实现"><meta property="og:description" content="sync.Mutex 和 sync.Cond 都是对于协程 g 来说的，而 m.mOS.mutex 和 m.mOS.cond 是对线程 m 来说的，底层用法大概相同。 runtime.mutex 在 sema 的实现方案下（不同系统决定着实现方案的不同），底层依赖 m.mOS.mutex 和 m.mOS.cond 来"><meta property="og:type" content="article"><meta property="og:url" content="https://xsc.scccc.cn/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"><meta property="article:published_time" content="2022-09-04T01:39:00+08:00"><meta property="article:modified_time" content="2022-09-04T01:39:00+08:00"><meta property="og:site_name" content="🏠 Xsc Study Notes"><meta name=twitter:card content="summary"><meta name=twitter:title content="4. runtime之mutex线程锁的实现"><meta name=twitter:description content="sync.Mutex 和 sync.Cond 都是对于协程 g 来说的，而 m.mOS.mutex 和 m.mOS.cond 是对线程 m 来说的，底层用法大概相同。 runtime.mutex 在 sema 的实现方案下（不同系统决定着实现方案的不同），底层依赖 m.mOS.mutex 和 m.mOS.cond 来"><meta name=application-name content="🏠 Xsc Study Notes"><meta name=apple-mobile-web-app-title content="🏠 Xsc Study Notes"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://xsc.scccc.cn/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/><link rel=prev href=https://xsc.scccc.cn/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/><link rel=next href=https://xsc.scccc.cn/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6-copy/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"4. runtime之mutex线程锁的实现","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xsc.scccc.cn\/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0\/"},"genre":"posts","keywords":"runtime, go底层实现","wordcount":3562,"url":"https:\/\/xsc.scccc.cn\/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0\/","datePublished":"2022-09-04T01:39:00+08:00","dateModified":"2022-09-04T01:39:00+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Xsc"},"description":""}</script></head><body data-header-desktop=auto data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="🏠 Xsc Study Notes"><span class=header-title-pre>🏠 </span><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/tags/>标签 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder=想找什么就来找吧 id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="🏠 Xsc Study Notes"><span class=header-title-pre>🏠 </span><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=想找什么就来找吧 id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/>所有文章</a><a class=menu-item href=/categories/>分类</a><a class=menu-item href=/tags/>标签</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">4. runtime之mutex线程锁的实现</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://xsc.scccc.cn title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Xsc</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/go-runtime/><i class="far fa-folder fa-fw" aria-hidden=true></i>go runtime</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-09-04>2022-09-04</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 3562 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 8 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept=true><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#mutex基于信号sema的实现>mutex基于信号sema的实现</a><ul><li><a href=#信号的实现>信号的实现</a><ul><li><a href=#持有结构>持有结构</a></li><li><a href=#semacreate>semacreate</a></li><li><a href=#semasleep>semasleep</a></li><li><a href=#semawakeup>semawakeup</a></li></ul></li><li><a href=#mutex-的加解锁操作>mutex 的加解锁操作</a><ul><li><a href=#获取锁-lock>获取锁 lock</a><ul><li><a href=#当一个线程需要获取一个锁的时候他执行流程如下>当一个线程需要获取一个锁的时候，他执行流程如下</a></li><li><a href=#为什么m要通过那种方式设置我们举个例子他这个算法很巧妙>为什么m要通过那种方式设置，我们举个例子，他这个算法很巧妙。</a></li></ul></li><li><a href=#释放锁>释放锁</a></li></ul></li></ul></li><li><a href=#mutex基于futex的实现>mutex基于futex的实现</a><ul><li><a href=#获取锁>获取锁</a></li><li><a href=#释放锁-1>释放锁</a></li></ul></li></ul></nav></div></div><div class=content id=content><p><code>sync.Mutex</code> 和 <code>sync.Cond</code> 都是对于协程 <code>g</code> 来说的，而 <code>m.mOS.mutex</code> 和 <code>m.mOS.cond</code> 是对线程 <code>m</code> 来说的，底层用法大概相同。</p><p><code>runtime.mutex</code> 在 <code>sema</code> 的实现方案下（不同系统决定着实现方案的不同），底层依赖 <code>m.mOS.mutex</code> 和 <code>m.mOS.cond</code> 来加解锁操控 <code>m</code> ，这时候 <code>mutex</code> 中的 <code>key</code> 是 <code>waitm</code> ，一个等待的 <code>m</code> 的地址。</p><p><code>runtime.mutex</code> 在 <code>futex</code> 的实现方案下，<code>key</code> 存储着锁的状态</p><h2 id=mutex基于信号sema的实现>mutex基于信号sema的实现</h2><h3 id=信号的实现>信号的实现</h3><ul><li><code>func semacreate(mp *m)</code> 为 <code>m</code> 创建信号量，如果它还没有的话。</li><li><code>func semasleep(ns int64) int32</code> 最长阻塞ns纳秒来得到一个信号量，成功返回0，失败返回-1</li><li><code>func semawakeup(mp *m)</code> 激活一个信号量</li></ul><p>我们使用 <code>semacreate</code> 创建信号量之后，我们的信号量是空的，我们使用 <code>semawakeup</code> 信号量才会得到一个信号，我们使用 <code>semasleep</code> 是为了得到一个信号量，这个信号量是 <code>semawakeup</code> 发送过来的，如果在我们规定的时间拿不到信号量，或者程序中断，都会返回-1。</p><h4 id=持有结构>持有结构</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// initialized 是否被初始化
</span><span class=c1>// mutex 互斥锁
</span><span class=c1>// cond 条件通知
</span><span class=c1>// count 当前可直接获取的信号量数量
</span><span class=c1></span><span class=kd>type</span> <span class=nx>mOS</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>initialized</span> <span class=kt>bool</span>
	<span class=nx>mutex</span>       <span class=nx>pthreadmutex</span>
	<span class=nx>cond</span>        <span class=nx>pthreadcond</span>
	<span class=nx>count</span>       <span class=kt>int</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p><code>semasleep</code> 和 <code>semawakeup</code> 本质都是操作 count<code> </code>的</p><p><code>semasleep</code> 是 <code>count - 1</code>，如果 <code>count == 0</code>，就要等一个 <code>semawakeup</code> 给它加1</p><p><code>semawakeup</code> 是 <code>count + 1</code>，如果 +1 后的 <code>count</code> 大于 0， 我们就要唤醒一个正在<code>sleep</code></p><h4 id=semacreate>semacreate</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 给m.mOS的mutex和cond做初始化，如果已经被初始化了就算了
</span><span class=c1>// 这里的mutex就是一个互斥体，防止多个线程并发访问修改数据导致出错的
</span><span class=c1></span><span class=kd>func</span> <span class=nf>semacreate</span><span class=p>(</span><span class=nx>mp</span> <span class=o>*</span><span class=nx>m</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 如果已经被初始化，就不要再初始化了
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>initialized</span> <span class=p>{</span>
		<span class=k>return</span>
	<span class=p>}</span>
	<span class=nx>mp</span><span class=p>.</span><span class=nx>initialized</span> <span class=p>=</span> <span class=kc>true</span>
   	<span class=c1>// 初始化锁，互斥体
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>pthread_mutex_init</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>mutex</span><span class=p>,</span> <span class=kc>nil</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;pthread_mutex_init&#34;</span><span class=p>)</span>
	<span class=p>}</span>
    <span class=c1>// 初始化条件通知
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nf>pthread_cond_init</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>cond</span><span class=p>,</span> <span class=kc>nil</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;pthread_cond_init&#34;</span><span class=p>)</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h4 id=semasleep>semasleep</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 阻塞来获取信号
</span><span class=c1>// ns如果小于0，它会一直阻塞等到能够获取信号为止
</span><span class=c1>// ns如果大于等于0，它会最大阻塞ns这么长的时间来获取信号
</span><span class=c1>// 成功返回0，失败返回其他
</span><span class=c1></span><span class=kd>func</span> <span class=nf>semasleep</span><span class=p>(</span><span class=nx>ns</span> <span class=kt>int64</span><span class=p>)</span> <span class=kt>int32</span> <span class=p>{</span>
	<span class=kd>var</span> <span class=nx>start</span> <span class=kt>int64</span>
    <span class=c1>// 如果我们有最大耗时，我们就要先记录一下我们调用时候的时间，方便后面算花费了多长时间
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>ns</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nx>start</span> <span class=p>=</span> <span class=nf>nanotime</span><span class=p>()</span>
	<span class=p>}</span>
    <span class=c1>// 得到m
</span><span class=c1></span>	<span class=nx>mp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>().</span><span class=nx>m</span>
    <span class=c1>// 上锁
</span><span class=c1></span>	<span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>mutex</span><span class=p>)</span>
	<span class=k>for</span> <span class=p>{</span>
        <span class=c1>// mp.count只有在唤醒一个信号的时候才会增加
</span><span class=c1></span>		<span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>count</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
            <span class=c1>// 如果里面得到一个信号，我们就让它--
</span><span class=c1></span>			<span class=nx>mp</span><span class=p>.</span><span class=nx>count</span><span class=o>--</span>
            <span class=c1>// 解锁就好了
</span><span class=c1></span>			<span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>mutex</span><span class=p>)</span>
			<span class=k>return</span> <span class=mi>0</span>
		<span class=p>}</span>
        <span class=c1>// ns &gt;= 0 说明我们有一个耗时检测
</span><span class=c1></span>		<span class=k>if</span> <span class=nx>ns</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=p>{</span>
            <span class=c1>// 判断一下我们当前花费的时间是不是超过我们的耗时了
</span><span class=c1></span>			<span class=nx>spent</span> <span class=o>:=</span> <span class=nf>nanotime</span><span class=p>()</span> <span class=o>-</span> <span class=nx>start</span>
			<span class=k>if</span> <span class=nx>spent</span> <span class=o>&gt;=</span> <span class=nx>ns</span> <span class=p>{</span>
                <span class=c1>// 超过我们就解锁并返回-1
</span><span class=c1></span>				<span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>mutex</span><span class=p>)</span>
				<span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
			<span class=p>}</span>
            <span class=c1>// t是一个时间量
</span><span class=c1></span>			<span class=kd>var</span> <span class=nx>t</span> <span class=nx>timespec</span>
            <span class=c1>// 计算剩余t的值
</span><span class=c1></span>			<span class=nx>t</span><span class=p>.</span><span class=nf>setNsec</span><span class=p>(</span><span class=nx>ns</span> <span class=o>-</span> <span class=nx>spent</span><span class=p>)</span>
            <span class=c1>// 我们开始等待一个条件通知，让我们能继续执行，最长阻塞时间为t，这里面传入mutex也是为了上锁，里面好修改状态
</span><span class=c1></span>			<span class=nx>err</span> <span class=o>:=</span> <span class=nf>pthread_cond_timedwait_relative_np</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>mutex</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>t</span><span class=p>)</span>
            <span class=c1>// 如果超时，我们就返回-1
</span><span class=c1></span>			<span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>_ETIMEDOUT</span> <span class=p>{</span>
				<span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>mutex</span><span class=p>)</span>
				<span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
			<span class=p>}</span>
            <span class=c1>// 没有超时，我们就继续循环了
</span><span class=c1></span>            <span class=c1>// 如果没有超时，证明cond得到了一个通知，我们的m.count是会++的，在上面会正常结束返回0
</span><span class=c1></span>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// 如果我们让无限等待，且当前没有得到一个信号，我们就直接等通知就好了
</span><span class=c1></span>			<span class=nf>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>mutex</span><span class=p>)</span>
            <span class=c1>// 拿到通知后，再循环到上面count肯定也会大于0，就返回0就好了
</span><span class=c1></span>		<span class=p>}</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h4 id=semawakeup>semawakeup</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// 唤醒一个信号，为我们的count++，并使用cond_signal进行通知
</span><span class=c1></span><span class=kd>func</span> <span class=nf>semawakeup</span><span class=p>(</span><span class=nx>mp</span> <span class=o>*</span><span class=nx>m</span><span class=p>)</span> <span class=p>{</span>
   <span class=c1>// 加锁，因为要操作m了
</span><span class=c1></span>   <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>mutex</span><span class=p>)</span>
   <span class=nx>mp</span><span class=p>.</span><span class=nx>count</span><span class=o>++</span>
   <span class=k>if</span> <span class=nx>mp</span><span class=p>.</span><span class=nx>count</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
      <span class=c1>// 如果count&gt;0，代表持有信号量，我们就通知cond
</span><span class=c1></span>      <span class=nf>pthread_cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>cond</span><span class=p>)</span>
   <span class=p>}</span>
   <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>mp</span><span class=p>.</span><span class=nx>mutex</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h3 id=mutex-的加解锁操作>mutex 的加解锁操作</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=c1>// locked 用最低位是不是1来判断是否处于锁定状态
</span><span class=c1>// active_spin 积极自旋的次数
</span><span class=c1>// passive_spin 消极自旋的次数
</span><span class=c1>// active_spin_cnt 用来自旋等待的
</span><span class=c1></span><span class=kd>const</span> <span class=p>(</span>
	<span class=nx>locked</span> <span class=kt>uintptr</span> <span class=p>=</span> <span class=mi>1</span>

	<span class=nx>active_spin</span>     <span class=p>=</span> <span class=mi>4</span>
	<span class=nx>active_spin_cnt</span> <span class=p>=</span> <span class=mi>30</span>
	<span class=nx>passive_spin</span>    <span class=p>=</span> <span class=mi>1</span>
<span class=p>)</span>
</code></pre></td></tr></table></div></div><h4 id=获取锁-lock>获取锁 lock</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>lock</span><span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>mutex</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// lockWithRank 在第三篇文章讲到了，就不说了
</span><span class=c1></span>    <span class=c1>// 判断锁排名是否合法
</span><span class=c1></span>	<span class=nf>lockWithRank</span><span class=p>(</span><span class=nx>l</span><span class=p>,</span> <span class=nf>getLockRank</span><span class=p>(</span><span class=nx>l</span><span class=p>))</span>
<span class=p>}</span>

<span class=c1>// 加锁操作
</span><span class=c1></span><span class=kd>func</span> <span class=nf>lock2</span><span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>mutex</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 得到g
</span><span class=c1></span>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>
    <span class=c1>// 判断m上锁的数量是不是异常的
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>locks</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime·lock: lock count&#34;</span><span class=p>)</span>
	<span class=p>}</span>
    <span class=c1>// 给lock++
</span><span class=c1></span>	<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>locks</span><span class=o>++</span>

	<span class=c1>// cas操作，判断l.key是不是0，如果是0，我们设置成locked，就结束了
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Casuintptr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>locked</span><span class=p>)</span> <span class=p>{</span>
		<span class=k>return</span>
	<span class=p>}</span>
    <span class=c1>// 如果不是0，我们先初始化一下信号量
</span><span class=c1></span>	<span class=nf>semacreate</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>)</span>

	<span class=c1>// 单核处理器不自旋，多核处理器自旋
</span><span class=c1></span>	<span class=nx>spin</span> <span class=o>:=</span> <span class=mi>0</span>
	<span class=k>if</span> <span class=nx>ncpu</span> <span class=p>&gt;</span> <span class=mi>1</span> <span class=p>{</span>
        <span class=c1>// 自旋4次
</span><span class=c1></span>		<span class=nx>spin</span> <span class=p>=</span> <span class=nx>active_spin</span>
	<span class=p>}</span>
<span class=nx>Loop</span><span class=p>:</span>
    <span class=c1>// 进入一个循环
</span><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=c1>// 获取key的值
</span><span class=c1></span>		<span class=nx>v</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Loaduintptr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>)</span>
        <span class=c1>// 判断key的最低位是不是0
</span><span class=c1></span>		<span class=k>if</span> <span class=nx>v</span><span class=o>&amp;</span><span class=nx>locked</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
			<span class=c1>// 是0的话，证明可以直接加锁
</span><span class=c1></span>            <span class=c1>// 我们尝试cas加锁，如果失败了，我们就让重新开始自旋
</span><span class=c1></span>			<span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Casuintptr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span> <span class=nx>v</span><span class=p>,</span> <span class=nx>v</span><span class=p>|</span><span class=nx>locked</span><span class=p>)</span> <span class=p>{</span>
				<span class=k>return</span>
			<span class=p>}</span>
            <span class=c1>// 如果还是被锁定的，我们就重新自旋
</span><span class=c1></span>			<span class=nx>i</span> <span class=p>=</span> <span class=mi>0</span>
		<span class=p>}</span>
        
		<span class=k>if</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>spin</span> <span class=p>{</span>
            <span class=c1>// i 如果小于自旋次数，调用procyield，资源消耗小
</span><span class=c1></span>            <span class=c1>// 阻塞一下
</span><span class=c1></span>			<span class=nf>procyield</span><span class=p>(</span><span class=nx>active_spin_cnt</span><span class=p>)</span>
		<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>spin</span><span class=o>+</span><span class=nx>passive_spin</span> <span class=p>{</span>
            <span class=c1>// 如果i大于等于自旋次数，我们判断是不是还小于加上消极的自旋次数，就执行osyield，资源消耗大
</span><span class=c1></span>            <span class=c1>// 阻塞一下
</span><span class=c1></span>			<span class=nf>osyield</span><span class=p>()</span>
		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// 不用自旋了，我们要给这个mutex进行入队等待了
</span><span class=c1></span>			<span class=c1>// l.key 挂载的是等待这个锁的 m 的链表
</span><span class=c1></span>			<span class=c1>// 通过 nextwaitm 来排队
</span><span class=c1></span>			<span class=k>for</span> <span class=p>{</span>
                <span class=c1>// gp.m.nextwaitm 设置成的 v中的m，也就是原来的m
</span><span class=c1></span>                <span class=c1>// l.key设置成现在的m
</span><span class=c1></span>                <span class=c1>// 那么关系就是l.key是现在的m
</span><span class=c1></span>                <span class=c1>// l.key的m的nextwaitm是上一个m了
</span><span class=c1></span>                <span class=c1>// 相当于入队到头部了
</span><span class=c1></span>				<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>nextwaitm</span> <span class=p>=</span> <span class=nf>muintptr</span><span class=p>(</span><span class=nx>v</span> <span class=o>&amp;^</span> <span class=nx>locked</span><span class=p>)</span>
                <span class=c1>// 如果v在中途没有被解锁，我们就把v设置成当前m的地址，最后一位设置成锁定中
</span><span class=c1></span>				<span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Casuintptr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span> <span class=nx>v</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>))|</span><span class=nx>locked</span><span class=p>)</span> <span class=p>{</span>
					<span class=k>break</span>
				<span class=p>}</span>
                <span class=c1>// 如果v被其他线程改变了，重新去一下v的新值（其他线程可能解锁了这个v）
</span><span class=c1></span>				<span class=nx>v</span> <span class=p>=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Loaduintptr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>)</span>
                <span class=c1>// 如果v当前处于解锁状态了
</span><span class=c1></span>				<span class=k>if</span> <span class=nx>v</span><span class=o>&amp;</span><span class=nx>locked</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
                    <span class=c1>// 继续外部循环了
</span><span class=c1></span>					<span class=k>continue</span> <span class=nx>Loop</span>
				<span class=p>}</span>
			<span class=p>}</span>
            <span class=c1>// 如果v锁定中，我们就挂起等待
</span><span class=c1></span>			<span class=k>if</span> <span class=nx>v</span><span class=o>&amp;</span><span class=nx>locked</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>{</span>
				<span class=c1>// 等待
</span><span class=c1></span>				<span class=nf>semasleep</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
				<span class=nx>i</span> <span class=p>=</span> <span class=mi>0</span>
			<span class=p>}</span>
		<span class=p>}</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h5 id=当一个线程需要获取一个锁的时候他执行流程如下>当一个线程需要获取一个锁的时候，他执行流程如下</h5><ol><li>判断key的值等于0（也就是一个新锁），那么就直接设置为1锁定状态，并返回</li><li>如果key不是0，证明里面要么是1，要么是存了一个waitm，我们就要初始化信号锁（更底层，仅会初始化一次）</li><li>获取是否应该自旋和设置自旋次数</li><li>进入自旋也就是循环，此时key可能是1或者是一个waitm，waitm的最低位标志着当前锁的状态，我们判断最低位等于0，我们直接设置最低位为1，返回即可</li><li>如果设置最低位为1失败（其他线程抢先一步修改了），我们需要重新自旋</li><li>在上一步验证结束后，如果自旋次数还未循环结束，我们让处理器执行等待，后继续循环获取锁状态</li><li>如果自旋次数结束，无法获取到锁，我们就让当前m的nextwaitm指向key，也就是前面正在阻塞的m的地址，让我们的key存储当前m的地址</li><li>如果存储我们的m失败，证明当前锁已经被其他线程释放了，我们就继续判断，重新进入自旋状态</li><li>如果存储成功，我们就等待sema信号的通知即可</li></ol><h5 id=为什么m要通过那种方式设置我们举个例子他这个算法很巧妙>为什么m要通过那种方式设置，我们举个例子，他这个算法很巧妙。</h5><table><thead><tr><th style=text-align:center></th><th>地址与计算</th><th>备注</th></tr></thead><tbody><tr><td style=text-align:center>m</td><td>0x1000</td><td>m就是我们的线程地址</td></tr><tr><td style=text-align:center>waitm</td><td>0x1001 (0x1000 &^ 0x1)</td><td>waitm就是我们的nextwaitm</td></tr><tr><td style=text-align:center>key</td><td>0x1001 (0x1000 | 0x1)</td><td>key就是mutex里面存储的</td></tr><tr><td style=text-align:center>getm</td><td>0x1000 (0x1001 &^ 0x1)</td><td>getm就是释放锁时从key里取到的m</td></tr></tbody></table><h4 id=释放锁>释放锁</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>unlock</span><span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>mutex</span><span class=p>)</span> <span class=p>{</span>
	<span class=nf>unlockWithRank</span><span class=p>(</span><span class=nx>l</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>unlock2</span><span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>mutex</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 获取g
</span><span class=c1></span>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>
	<span class=kd>var</span> <span class=nx>mp</span> <span class=o>*</span><span class=nx>m</span>
	<span class=k>for</span> <span class=p>{</span>
        <span class=c1>// 获取锁上存的key，也就是waitm以及锁定状态
</span><span class=c1></span>		<span class=nx>v</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Loaduintptr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>)</span>
        <span class=c1>// 如果锁定中，直接解锁
</span><span class=c1></span>		<span class=k>if</span> <span class=nx>v</span> <span class=o>==</span> <span class=nx>locked</span> <span class=p>{</span>
            <span class=c1>// cas操作解锁
</span><span class=c1></span>			<span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Casuintptr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span> <span class=nx>locked</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
				<span class=k>break</span>
			<span class=p>}</span>
		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
            <span class=c1>// 当前v不是单纯的锁定状态，里面存储了m信息
</span><span class=c1></span>            <span class=c1>// 取到m的指针
</span><span class=c1></span>			<span class=nx>mp</span> <span class=p>=</span> <span class=nf>muintptr</span><span class=p>(</span><span class=nx>v</span> <span class=o>&amp;^</span> <span class=nx>locked</span><span class=p>).</span><span class=nf>ptr</span><span class=p>()</span>
            <span class=c1>// 让我们的key指向下一个等待的m身上
</span><span class=c1></span>			<span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Casuintptr</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>,</span> <span class=nx>v</span><span class=p>,</span> <span class=nb>uintptr</span><span class=p>(</span><span class=nx>mp</span><span class=p>.</span><span class=nx>nextwaitm</span><span class=p>))</span> <span class=p>{</span>
                <span class=c1>// 唤醒mp
</span><span class=c1></span>				<span class=nf>semawakeup</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span>
				<span class=k>break</span>
			<span class=p>}</span>
		<span class=p>}</span>
	<span class=p>}</span>
    <span class=c1>// 解锁成功
</span><span class=c1></span>	<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>locks</span><span class=o>--</span>
	<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>locks</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime·unlock: lock count&#34;</span><span class=p>)</span>
	<span class=p>}</span>
    <span class=c1>// 如果m上没有锁了，就恢复抢占请求
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>locks</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>preempt</span> <span class=p>{</span> <span class=c1>// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span class=c1></span>		<span class=nx>gp</span><span class=p>.</span><span class=nx>stackguard0</span> <span class=p>=</span> <span class=nx>stackPreempt</span>
	<span class=p>}</span>
<span class=p>}</span>

</code></pre></td></tr></table></div></div><h2 id=mutex基于futex的实现>mutex基于futex的实现</h2><h3 id=获取锁>获取锁</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>lock</span><span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>mutex</span><span class=p>)</span> <span class=p>{</span>
	<span class=nf>lockWithRank</span><span class=p>(</span><span class=nx>l</span><span class=p>,</span> <span class=nf>getLockRank</span><span class=p>(</span><span class=nx>l</span><span class=p>))</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>lock2</span><span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>mutex</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 拿到g
</span><span class=c1></span>	<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>
	<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>locks</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime·lock: lock count&#34;</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>locks</span><span class=o>++</span>

	<span class=c1>// 把l.key设置成mutex_locked
</span><span class=c1></span>	<span class=nx>v</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Xchg</span><span class=p>(</span><span class=nf>key32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>),</span> <span class=nx>mutex_locked</span><span class=p>)</span>
    <span class=c1>// 判断原来l.key是不是解锁状态，拿到锁了
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>v</span> <span class=o>==</span> <span class=nx>mutex_unlocked</span> <span class=p>{</span>
		<span class=k>return</span>
	<span class=p>}</span>

    <span class=c1>// wait 现在是 MUTEX_LOCKED 或者 MUTEX_SLEEPING状态
</span><span class=c1></span>	<span class=nx>wait</span> <span class=o>:=</span> <span class=nx>v</span>

	<span class=nx>spin</span> <span class=o>:=</span> <span class=mi>0</span>
	<span class=k>if</span> <span class=nx>ncpu</span> <span class=p>&gt;</span> <span class=mi>1</span> <span class=p>{</span>
		<span class=nx>spin</span> <span class=p>=</span> <span class=nx>active_spin</span>
	<span class=p>}</span>
	<span class=k>for</span> <span class=p>{</span>
		<span class=c1>// 积极自旋，再次尝试解锁
</span><span class=c1></span>		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>spin</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
            <span class=c1>// 如果其他线程把锁释放了，我们这边就能拿到了，并且把锁状态，设置成我们上面本来的状态
</span><span class=c1></span>			<span class=k>for</span> <span class=nx>l</span><span class=p>.</span><span class=nx>key</span> <span class=o>==</span> <span class=nx>mutex_unlocked</span> <span class=p>{</span>
				<span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Cas</span><span class=p>(</span><span class=nf>key32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>),</span> <span class=nx>mutex_unlocked</span><span class=p>,</span> <span class=nx>wait</span><span class=p>)</span> <span class=p>{</span>
					<span class=k>return</span>
				<span class=p>}</span>
			<span class=p>}</span>
			<span class=nf>procyield</span><span class=p>(</span><span class=nx>active_spin_cnt</span><span class=p>)</span>
		<span class=p>}</span>

		<span class=c1>// 消极自旋，与上面相同，就是换成了osyield
</span><span class=c1></span>		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>passive_spin</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
			<span class=k>for</span> <span class=nx>l</span><span class=p>.</span><span class=nx>key</span> <span class=o>==</span> <span class=nx>mutex_unlocked</span> <span class=p>{</span>
				<span class=k>if</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Cas</span><span class=p>(</span><span class=nf>key32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>),</span> <span class=nx>mutex_unlocked</span><span class=p>,</span> <span class=nx>wait</span><span class=p>)</span> <span class=p>{</span>
					<span class=k>return</span>
				<span class=p>}</span>
			<span class=p>}</span>
			<span class=nf>osyield</span><span class=p>()</span>
		<span class=p>}</span>

		<span class=c1>// 我们再获取一次，获取到了就ok，再挂载到futex的时候一定是sleeping状态
</span><span class=c1></span>		<span class=nx>v</span> <span class=p>=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Xchg</span><span class=p>(</span><span class=nf>key32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>),</span> <span class=nx>mutex_sleeping</span><span class=p>)</span>
		<span class=k>if</span> <span class=nx>v</span> <span class=o>==</span> <span class=nx>mutex_unlocked</span> <span class=p>{</span>
			<span class=k>return</span>
		<span class=p>}</span>
        <span class=c1>// 来到这块，证明我们的锁获取不到了，我们要去睡眠了
</span><span class=c1></span>		<span class=nx>wait</span> <span class=p>=</span> <span class=nx>mutex_sleeping</span>
		<span class=nf>futexsleep</span><span class=p>(</span><span class=nf>key32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>),</span> <span class=nx>mutex_sleeping</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><h3 id=释放锁-1>释放锁</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>unlock</span><span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>mutex</span><span class=p>)</span> <span class=p>{</span>
	<span class=nf>unlockWithRank</span><span class=p>(</span><span class=nx>l</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>unlock2</span><span class=p>(</span><span class=nx>l</span> <span class=o>*</span><span class=nx>mutex</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// 把锁设置成mutex_unlocked
</span><span class=c1></span>	<span class=nx>v</span> <span class=o>:=</span> <span class=nx>atomic</span><span class=p>.</span><span class=nf>Xchg</span><span class=p>(</span><span class=nf>key32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>),</span> <span class=nx>mutex_unlocked</span><span class=p>)</span>
    <span class=c1>// 判断原来是不是就是解锁状态
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>v</span> <span class=o>==</span> <span class=nx>mutex_unlocked</span> <span class=p>{</span>
		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;unlock of unlocked lock&#34;</span><span class=p>)</span>
	<span class=p>}</span>
    <span class=c1>// 如果锁在睡眠中，我们就唤醒一个
</span><span class=c1></span>	<span class=k>if</span> <span class=nx>v</span> <span class=o>==</span> <span class=nx>mutex_sleeping</span> <span class=p>{</span>
		<span class=nf>futexwakeup</span><span class=p>(</span><span class=nf>key32</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>l</span><span class=p>.</span><span class=nx>key</span><span class=p>),</span> <span class=mi>1</span><span class=p>)</span>
	<span class=p>}</span>

	<span class=nx>gp</span> <span class=o>:=</span> <span class=nf>getg</span><span class=p>()</span>
	<span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>locks</span><span class=o>--</span>
	<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>locks</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime·unlock: lock count&#34;</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=k>if</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>locks</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>gp</span><span class=p>.</span><span class=nx>preempt</span> <span class=p>{</span> <span class=c1>// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span class=c1></span>		<span class=nx>gp</span><span class=p>.</span><span class=nx>stackguard0</span> <span class=p>=</span> <span class=nx>stackPreempt</span>
	<span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-09-04</span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://xsc.scccc.cn/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/ data-title="4. runtime之mutex线程锁的实现"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://xsc.scccc.cn/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/ data-title="4. runtime之mutex线程锁的实现"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://xsc.scccc.cn/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/ data-title="4. runtime之mutex线程锁的实现"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://xsc.scccc.cn/4.-runtime%E4%B9%8Bmutex%E7%BA%BF%E7%A8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/ data-title="4. runtime之mutex线程锁的实现"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/baidu.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/runtime/>runtime</a>,&nbsp;<a href=/tags/go%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/>go底层实现</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/3.-runtime%E4%B9%8Blockrank%E9%94%81%E6%8E%92%E5%90%8D%E6%9C%BA%E5%88%B6/ class=prev rel=prev title="3. runtime之lockRank锁排名机制"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>3. runtime之lockRank锁排名机制</a>
<a href=/5.-runtime%E4%B9%8Bnote%E4%B8%80%E6%AC%A1%E6%80%A7%E9%80%9A%E7%9F%A5%E4%BA%8B%E4%BB%B6-copy/ class=next rel=next title="5. runtime之note一次性通知事件">5. runtime之note一次性通知事件<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=utterances class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://utteranc.es/>utterances</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xsc.scccc.cn target=_blank>Xsc</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a href=https://beian.miit.gov.cn>晋ICP备20005176号-1</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/css/lightgallery-bundle.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/twemoji@14.0.2/dist/twemoji.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/lightgallery.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/thumbnail/lg-thumbnail.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/zoom/lg-zoom.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":50},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"pathname","label":"actposts","lightTheme":"github-light","repo":"xue1213888/xue1213888"}},"data":{"id-1":"Xsc Study Notes","id-2":"Xsc Study Notes"},"lightgallery":true,"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":30,"type":"lunr"},"twemoji":true,"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type=text/javascript src=/js/theme.min.js></script></body></html>