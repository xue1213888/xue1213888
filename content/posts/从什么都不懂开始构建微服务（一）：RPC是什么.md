---
title: "从什么都不懂开始构建微服务（一）：RPC是什么"
date: 2021-08-10T14:52:05+08:00
tags: ["rpc","微服务","grpc"]
categories: ["golang","微服务"]
draft: false
---
## 什么是RPC

- `本地过程调用`：通过指定本地函数指针来进行服务处理！
    
    这个就好比你现在在家吃完饭，想要洗碗，你就得打开洗碗机，把碗放进洗碗机，然后打开开关。这样就实现了本地调用！
    
- `RPC（Remote Procedure Call）`远程过程调用：就是一个节点请求另一个节点提供的服务！

    RPC的话就变成，你吃完饭了，想洗碗，但是你没有洗碗机，我是一个专门提供洗碗服务的洗碗店，你把碗给了我，我把洗完的碗给你。这样就是一个RPC调用了！

## 这是一个本地调用的洗碗机

下面演示了本地过程调用。我们在调用`Wash`函数的时候初始化了一个函数的栈，把`bowl`压入栈中，调用结束后函数把返回结果也压入栈中，我们从内存中获取到返回结果。
```golang
func Wash(Bowl string) string {
    return fmt.Sprints(" %s 洗好了！", Bowl)
}

bowl := "碗"
over := Wash(bowl)

fmt.Println(over)
```

## 这时候我们想把洗碗机变成一个远程的服务，就会面临以下问题

- `Call的id映射`

    **你现在想要洗碗，就得告诉我们洗碗店，你是要洗碗，不是洗脚。我一听，是要洗碗呀，就给业务部门的业务员说让他来转接处理。这个`洗碗就是一个id`，`Call映射的就是洗碗店的业务员`。**

    我们怎么告诉远程服务我们要调用`Wash`，而不是其他函数呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用`Wash`，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 <--> Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码，再返回给用户。

- `序列化和反序列化`

    **这时候我们的业务员说，我们要求10个碗放一摞，6摞放一箱，不然我们处理不了，不给你洗。你就得按照我们的规矩来，这个就称为`序列化`。我们收到碗之后会把碗拆成一个一个洗，叫做`反序列化`，洗完了之后又`序列化`发给你，你自己`反序列`化放到碗柜去。**

- `网络传输`

    **商量好了之后，我们就需要把碗发过去，这时候可能有很多种方式，你自己开车去、叫快递送过去都行，人家完了又给你送回来。**

## 暂时结束